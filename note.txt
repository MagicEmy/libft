Automatic Variables
Automatic variables are set by make after a rule is matched. They provide access to
elements from the target and prerequisite lists so you don’t have to explicitly specify
any filenames. They are very useful for avoiding code duplication, but are critical
when defining more general pattern rules (discussed later).
There are six “core” automatic variables:
$@ The filename representing the target.
$% The filename element of an archive member specification.
$< The filename of the first prerequisite.
$? The names of all prerequisites that are newer than the target, separated by
spaces.
$^ The filenames of all the prerequisites, separated by spaces. This list has duplicate filenames removed since for most uses, such as compiling, copying, etc.,
duplicates are not wanted.
$+ Similar to $^, this is the names of all the prerequisites separated by spaces,
except that $+ includes duplicates. This variable was created for specific situations such as arguments to linkers where duplicate values have meaning.
$* The stem of the target filename. A stem is typically a filename without its suffix.
(We’ll discuss how stems are computed later in the section “Pattern Rules.”) Its
use outside of pattern rules is discouraged.
In addition, each of the above variables has two variants for compatibility with other
makes. One variant returns only the directory portion of the value. This is indicated
by appending a “D” to the symbol, $(@D), $(<D), etc. The other variant returns only
the file portion of the value. This is indicated by appending an F to the symbol,
$(@F), $(<F), etc. Note that these variant names are more than one character long
and so must be enclosed in parentheses. GNU make provides a more readable alternative with the dir and notdir functions. We will discuss functions in Chapter 4.
Automatic variables are set by make after a rule has been matched with its target and
prerequisites so the variables are only available in the command script of a rule.
Here is our makefile with explicit filenames replaced by the appropriate automatic
variable.
count_words: count_words.o counter.o lexer.o -lfl
 gcc $^ -o $@
count_words.o: count_words.c
 gcc -c $<
counter.o: counter.c
 gcc -c $<
lexer.o: lexer.c
 gcc -c $<
lexer.c: lexer.l
 flex -t $< > $@

FINDING FILES WITH VPATH AND VPATH
A reusable library function should have a declaration in a header file, so let’s create
counter.h containing our declaration:
#ifdef COUNTER_H_
#define COUNTER_H_
extern void
counter( int counts[4] );
#endif
We can also place the declarations for our lexer.l symbols in lexer.h:
#ifndef LEXER_H_
#define LEXER_H_
extern int fee_count, fie_count, foe_count, fum_count;
extern int yylex( void );
#endif
In a traditional source tree layout the header files are placed in an include directory
and the source is placed in a src directory. We’ll do this and put our makefile in the
parent directory.